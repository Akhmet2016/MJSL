/////prompt/////////////////////////////////////////////////////////////////////////

Функция prompt принимает два аргумента:

result = prompt(title, default);
Она выводит модальное окно с заголовком title, полем для ввода текста,
заполненным строкой по умолчанию default и кнопками OK/CANCEL.

Пользователь должен либо что-то ввести и нажать OK, либо отменить ввод кликом на CANCEL
или нажатием Esc на клавиатуре.

Пример: prompt("messag", "go in the club");

/////confirm/////////////////////////////////////////////////////////////////////////

Синтаксис:

result = confirm(question);
confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.

Результатом будет true при нажатии OK и false – при CANCEL(Esc).

Например:

 var isAdmin = confirm("Вы - администратор?");

alert( isAdmin );

////////////////////////////////////////////////////////////////////////////////////

outer: for (var i = 0; i < 3; i++) {

  for (var j = 0; j < 3; j++) {

    var input = prompt('Значение в координатах '+i+','+j, '');

    // если отмена ввода или пустая строка -
    // завершить оба цикла
    if (!input) break outer; // (*)

  }
}
alert('Готово!');

////////////////////////new Function/////////////////////////////////////////////

Существует ещё один способ создания функции, который используется очень редко, но упомянем
и его для полноты картины.

Он позволяет создавать функцию полностью «на лету» из строки, вот так:


var sum = new Function('a,b', ' return a+b; ');
var result = sum(1, 2);
alert( result ); // 3


То есть, функция создаётся вызовом new Function(params, code):
params
Параметры функции через запятую в виде строки.
code
Код функции в виде строки.
Таким образом можно конструировать функцию, код которой неизвестен на момент написания
программы, но строка с ним генерируется или подгружается динамически во время её выполнения.

/////////////////////////////BDD – поведенческие тесты кода////////////////////////////////////

Мы рассмотрим методику тестирования, которая входит в BDD – Behavior Driven Development. Подход BDD
давно и с успехом используется во многих проектах.

BDD – это не просто тесты. Это гораздо больше.

Тесты BDD – это три в одном: И тесты, И документация, И примеры использования.

Впрочем, хватит слов. Рассмотрим примеры.

Разработка pow: спецификация
Допустим, мы хотим разработать функцию pow(x, n), которая возводит x в целую степень n, для простоты n?0.

Ещё до разработки мы можем представить себе, что эта функция будет делать, и описать это по методике BDD.

Это описание называется спецификация (или, как говорят в обиходе, «спека») и выглядит так:

describe("pow", function() {

  it("возводит в n-ю степень", function() {
    assert.equal(pow(2, 3), 8);
  });

});
У спецификации есть три основных строительных блока, которые вы видите в примере выше:

describe(название, function() { ... })
Задаёт, что именно мы описываем, используется для группировки «рабочих лошадок» – блоков it. В данном случае
мы описываем функцию pow.

it(название, function() { ... })
В названии блока it человеческим языком описывается, что должна делать функция, далее следует тест, который проверяет это.

assert.equal(value1, value2)
Код внутри it, если реализация верна, должен выполняться без ошибок.

Различные функции вида assert.* используются, чтобы проверить, делает ли pow то, что задумано. Пока что нас интересует
только одна из них – assert.equal, она сравнивает свой первый аргумент со вторым и выдаёт ошибку в случае, когда они не равны.
В данном случае она проверяет, что результат pow(2, 3) равен 8.

Есть и другие виды сравнений и проверок, которые мы увидим далее.

////////////////////////////////////////before/after и beforeEach/afterEach////////////////////////////////////////////////

В каждом блоке describe можно также задать функции before/after, которые будут выполнены до/после запуска тестов,
а также beforeEach/afterEach, которые выполняются до/после каждого it.

Например:

describe("Тест", function() {

  before(function() { alert("Начало тестов"); });
  after(function() { alert("Конец тестов"); });

  beforeEach(function() { alert("Вход в тест"); });
  afterEach(function() { alert("Выход из теста"); });

  it('тест 1', function() { alert('1'); });
  it('тест 2', function() { alert('2'); });

});
Последовательность будет такой:

Начало тестов
Вход в тест
1
Выход из теста
Вход в тест
2
Выход из теста
Конец тестов

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Вот самые востребованные assert-проверки, встроенные в Chai:

assert(value) – проверяет что value является true в логическом контексте.
assert.equal(value1, value2) – проверяет равенство value1 == value2.
assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.
assert.notEqual, assert.notStrictEqual – проверки, обратные двум предыдущим.
assert.isTrue(value) – проверяет, что value === true
assert.isFalse(value) – проверяет, что value === false
…более полный список – в документации

///////////////////////

Метод str.toUpperCase()
Также у строк есть метод toUpperCase(), который возвращает строку в верхнем регистре:
////////////////////

Метод num.toFixed(n)
Есть методы и у чисел, например num.toFixed(n). Он округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки (удобно для форматированного вывода):
//////////////////////////////////////////////////////////

Значение NaN можно проверить специальной функцией isNaN(n)
//////////////////////////////////////////////////////////////////////////////////////////////////////

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity
////////////////////////////////////////////////////////////////////////////////////////////////

Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity – используйте следующую функцию isNumeric:

function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

//////////////////////////////////////

Округление
Одна из самых частых операций с числом – округление. В JavaScript существуют целых 3 функции для этого.

Math.floor
Округляет вниз
Math.ceil
Округляет вверх
Math.round
Округляет до ближайшего целого
alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3

//////////////////////////////////////////////////////////////////////////////////////////////////

Форматирование
Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString():

var number = 123456789;

alert( number.toLocaleString() ); // 123 456 789

////////////////////////////////////////////////////////////////////////////////////////

Специальные символы
Символ	Описание
\b	Backspace
\f	Form feed
\n	New line
\r	Carriage return
\t	Tab
\uNNNN	Символ в кодировке Юникод с шестнадцатеричным кодом `NNNN`. Например, `\u00A9` -- юникодное представление символа копирайт ©
Экранирование специальных символов
Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем \'

////////////////////////////////////////////////////////////////////////////////////////////////

Длина length
Одно из самых частых действий со строкой – это получение ее длины:
alert( str.length );

Доступ к символам
Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0:
alert( str.charAt(0)
Также для доступа к символу можно использовать квадратные скобки:
alert( str[0] );
Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined.

var str = "строка";
str = str[3] + str[4] + str[5];
alert( str ); // ока

Смена регистра
Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний.

На заметку:
Для красивого вызова indexOf применяется побитовый оператор НЕ '~'.
Дело в том, что вызов ~n эквивалентен выражению -(n+1), например:
alert( ~2 ); // -(2+1) = -3
alert( ~1 ); // -(1+1) = -2
alert( ~0 ); // -(0+1) = -1
alert( ~-1 ); // -(-1+1) = 0
Как видно, ~n – ноль только в случае, когда n == -1.
То есть, проверка if ( ~str.indexOf(...) ) означает, что результат indexOf отличен от -1, т.е. совпадение есть.
Вот так:
var str = "Widget";
if (~str.indexOf("get")) {
  alert( 'совпадение есть!' );
}
Вообще, использовать возможности языка неочевидным образом не рекомендуется, поскольку ухудшает читаемость кода.
Однако, в данном случае, все в порядке. Просто запомните: '~' читается как «не минус один», а "if ~str.indexOf" читается как "если найдено".

//////////////////////////////////////////////

Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.
Если аргумент end отсутствует, то идет до конца строки.

substr(start [, length])
Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов.
var str = "stringify";
str = str.substr(2,4); // ring, со 2-й позиции 4 символа
alert(str)
Если второго аргумента нет – подразумевается «до конца строки».

slice(start [, end])
Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring

Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами:
substring(start, end)
Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:
alert( "testme".substring(-2) ); // "testme", -2 становится 0
Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
alert( "testme".substring(4, -1) ); // "test"
// -1 становится 0 -> получили substring(4, 0)
// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
slice
Отрицательные значения отсчитываются от конца строки:
alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
Это гораздо более удобно, чем странная логика substring.
Отрицательное значение первого параметра поддерживается в substr во всех браузерах, кроме IE8-.
Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет slice: он и отрицательные аргументы поддерживает и работает наиболее очевидно.
String.fromCharCode(code)
Возвращает символ по коду code:
alert( String.fromCharCode(1072) ); // 'а'
…И метод для получения цифрового кода из символа:
str.charCodeAt(pos)
Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.
alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'


Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны.


/////////////////////////////////////////////////////////////////////////

Создание объектов
Пустой объект («пустой шкаф») может быть создан одним из двух синтаксисов:

1. o = new Object();
2. o = {}; // пустые фигурные скобки
Обычно все пользуются синтаксисом (2), т.к. он короче.

Удаление осуществляется командой delete
delete persone.age;

Иногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом.
Для этого есть особый оператор: "in".
if ("name" in person) {
  alert( "Свойство name существует!" );
}

Впрочем, чаще используется другой способ – сравнение значения с undefined.
Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет.
Ошибки не будет.
Но если свойство не существует, то вернется специальное значение undefined:
var person = {};
alert( person.lalala ); // undefined, нет свойства с ключом lalala

Таким образом мы можем легко проверить существование свойства – получив его и сравнив с undefined:
var person = {
name: "Василий"
};
alert( person.lalala === undefined ); // true, свойства нет
alert( person.name === undefined ); // false, свойство есть.

Записи person['name'] и person.name идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку:

Доступ к свойству через переменную
Квадратные скобки также позволяют обратиться к свойству, имя которого хранится в переменной:
var person = {};
person.age = 25;
var key = 'age';
alert( person[key] ); // выведет person['age']

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Объекты: перебор свойств
Для перебора всех свойств из объекта используется цикл по свойствам for..in. Эта синтаксическая конструкция отличается от рассмотренного ранее цикла for(;;).
for..in
Синтаксис:
for (key in obj) {
  /* ... делать что-то с obj[key] ... */
}
При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key и вызвано тело цикла.
Объявление переменной в цикле for (var key in obj)
Вспомогательную переменную key можно объявить прямо в цикле:
for (var key in menu) {
// ...
}
Так иногда пишут для краткости кода. Можно использовать и любое другое название, кроме key, например for(var propName in menu).
Пример итерации по свойствам:
var menu = {
  width: 300,
  height: 200,
  title: "Menu"
};
for (var key in menu) {
  // этот код будет вызван для каждого свойства объекта
  // ..и выведет имя свойства и его значение

  alert( "Ключ: " + key + " значение: " + menu[key] );
}

//////////////////////////////////////////

Для проверки на число используйте функцию:
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n)
}

/////////////////////////////////////////////////////////////////////////////////////////

Конец массива

pop
Удаляет последний элемент из массива и возвращает его:
 var fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.pop() ); // удалили "Груша"
alert( fruits ); // Яблоко, Апельсин

push
Добавляет элемент в конец массива:
 var fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert( fruits ); // Яблоко, Апельсин, Груша
Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....

Начало массива

shift
Удаляет из массива первый элемент и возвращает его:
var fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.shift() ); // удалили Яблоко
alert( fruits ); // Апельсин, Груша

unshift
Добавляет элемент в начало массива:
var fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert( fruits ); // Яблоко, Апельсин, Груша

Методы push и unshift могут добавлять сразу по несколько элементов:
 var fruits = ["Яблоко"];
fruits.push("Апельсин", "Персик");
fruits.unshift("Ананас", "Лимон");
// результат: ["Ананас", "Лимон", "Яблоко", "Апельсин", "Персик"]
alert( fruits );

////////////////////////////////////////////////////////////////////////////

Код для генерации случайного целого от min to max включительно:
var rand = min + Math.floor(Math.random() * (max + 1 - min));

////////////////////////////////////////////////////////////////////////////

К счастью, есть метод split(s), который позволяет превратить строку в массив, разбив ее по разделителю s. В примере ниже таким разделителем является строка из запятой и пробела.
 var names = 'Маша, Петя, Марина, Василий';
var arr = names.split(', ');
for (var i = 0; i < arr.length; i++) {
  alert( 'Вам сообщение ' + arr[i] );
}

У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен:
alert( "a,b,c,d".split(',', 2) ); // a,b

Вызов split с пустой строкой разобьёт по буквам:
var str = "тест";
alert( str.split('') ); // т,е,с,т

Вызов arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель.
Например:
 var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
var str = arr.join(';');
alert( str ); // Маша;Петя;Марина;Василий

new Array + join = Повторение строки
Код для повторения строки 3 раза:
 alert( new Array(4).join("ля") ); // ляляля
Как видно, new Array(4) делает массив без элементов длины 4, который join объединяет в строку, вставляя между его элементами строку "ля".
В результате, так как элементы пусты, получается повторение строки. Такой вот небольшой трюк.

Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным delete:
 var arr = ["Я", "иду", "домой"];
delete arr[1]; // значение с индексом 1 удалено
// теперь arr = ["Я", undefined, "домой"];
alert( arr[1] ); // undefined

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Метод splice

Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.

Его синтаксис:
arr.splice(index[, deleteCount, elem1, ..., elemN])
Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.
Этот метод проще всего понять, рассмотрев примеры.

Начнём с удаления:
var arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); //  осталось ["Я", "JavaScript"]

В следующем примере мы удалим 3 элемента и вставим другие на их место:
var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// удалить 3 первых элемента и добавить другие вместо них
arr.splice(0, 3, "Мы", "изучаем")
alert( arr ) // теперь ["Мы", "изучаем", "JavaScript"]

Здесь видно, что splice возвращает массив из удаленных элементов:
var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// удалить 2 первых элемента
var removed = arr.splice(0, 2);
alert( removed ); // "Я", "сейчас" <-- array of removed elements

Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
var arr = ["Я", "изучаю", "JavaScript"];
// с позиции 2
// удалить 0
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:
var arr = [1, 2, 5]
// начиная с позиции индексом -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);
alert( arr ); // результат: 1,2,3,4,5

/////////////////////////////////////////////////////////////////////////////////

Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.

Например:
var arr = ["Почему", "надо", "учить", "JavaScript"];
var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)
alert( arr2 ); // надо, учить

/////////////////////////////////////////////////////////////////////////////////////

Сортировка, метод sort(fn)
Метод sort() сортирует массив на месте. Например:
var arr = [ 1, 2, 15 ];
arr.sort();
alert( arr );  // 1, 15, 2
Не заметили ничего странного в этом примере?
Порядок стал 1, 15, 2, это точно не сортировка чисел. Почему?
Это произошло потому, что по умолчанию sort сортирует, преобразуя элементы к строке.
Поэтому и порядок у них строковый, ведь "2" > "15".

Свой порядок сортировки
Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
Внутренний алгоритм функции сортировки умеет сортировать любые массивы – апельсинов, яблок, пользователей, и тех и других и третьих – чего угодно. Но для этого ему нужно знать, как их сравнивать. Эту роль и выполняет fn.
Если эту функцию не указать, то элементы сортируются как строки.
Например, укажем эту функцию явно, отсортируем элементы массива как числа:
function compareNumeric(a, b) {
if (a > b) return 1;
if (a < b) return -1;
}
var arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15
Обратите внимание, мы передаём в sort() именно саму функцию compareNumeric, без вызова через скобки. 

/////////////////////////////////////////////////////

reverse
Метод arr.reverse() меняет порядок элементов в массиве на обратный.
 var arr = [1, 2, 3];
arr.reverse();
alert( arr ); // 3,2,1

//////////////////////////////////////////////////////////////////////////////

concat
Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
Например:
var arr = [1, 2];
var newArr = arr.concat(3, 4);
alert( newArr ); // 1,2,3,4

////////////////////////////////////////////////////////////////////////////////////////

indexOf/lastIndexOf
Эти методы не поддерживаются в IE8-. Для их поддержки подключите библиотеку ES5-shim.
Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.
Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива.
Для поиска используется строгое сравнение ===.
Например:
var arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

Метод «arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, если он указан.

//////////////////////////////////////////////////////////////////////////////////////////

Object.keys(obj)
Ранее мы говорили о том, что свойства объекта можно перебрать в цикле for..in.
Если мы хотим работать с ними в виде массива, то к нашим услугам – замечательный метод Object.keys(obj). Он поддерживается везде, кроме IE8-:
 var user = {
  name: "Петя",
  age: 30
}
var keys = Object.keys(user);
alert( keys ); // name, age