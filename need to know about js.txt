/////prompt/////////////////////////////////////////////////////////////////////////

Функция prompt принимает два аргумента:

result = prompt(title, default);
Она выводит модальное окно с заголовком title, полем для ввода текста,
заполненным строкой по умолчанию default и кнопками OK/CANCEL.

Пользователь должен либо что-то ввести и нажать OK, либо отменить ввод кликом на CANCEL
или нажатием Esc на клавиатуре.

Пример: prompt("messag", "go in the club");

/////confirm/////////////////////////////////////////////////////////////////////////

Синтаксис:

result = confirm(question);
confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.

Результатом будет true при нажатии OK и false – при CANCEL(Esc).

Например:

 var isAdmin = confirm("Вы - администратор?");

alert( isAdmin );

////////////////////////////////////////////////////////////////////////////////////

outer: for (var i = 0; i < 3; i++) {

  for (var j = 0; j < 3; j++) {

    var input = prompt('Значение в координатах '+i+','+j, '');

    // если отмена ввода или пустая строка -
    // завершить оба цикла
    if (!input) break outer; // (*)

  }
}
alert('Готово!');

////////////////////////new Function/////////////////////////////////////////////

Существует ещё один способ создания функции, который используется очень редко, но упомянем
и его для полноты картины.

Он позволяет создавать функцию полностью «на лету» из строки, вот так:


var sum = new Function('a,b', ' return a+b; ');
var result = sum(1, 2);
alert( result ); // 3


То есть, функция создаётся вызовом new Function(params, code):
params
Параметры функции через запятую в виде строки.
code
Код функции в виде строки.
Таким образом можно конструировать функцию, код которой неизвестен на момент написания
программы, но строка с ним генерируется или подгружается динамически во время её выполнения.

/////////////////////////////BDD – поведенческие тесты кода////////////////////////////////////

Мы рассмотрим методику тестирования, которая входит в BDD – Behavior Driven Development. Подход BDD
давно и с успехом используется во многих проектах.

BDD – это не просто тесты. Это гораздо больше.

Тесты BDD – это три в одном: И тесты, И документация, И примеры использования.

Впрочем, хватит слов. Рассмотрим примеры.

Разработка pow: спецификация
Допустим, мы хотим разработать функцию pow(x, n), которая возводит x в целую степень n, для простоты n?0.

Ещё до разработки мы можем представить себе, что эта функция будет делать, и описать это по методике BDD.

Это описание называется спецификация (или, как говорят в обиходе, «спека») и выглядит так:

describe("pow", function() {

  it("возводит в n-ю степень", function() {
    assert.equal(pow(2, 3), 8);
  });

});
У спецификации есть три основных строительных блока, которые вы видите в примере выше:

describe(название, function() { ... })
Задаёт, что именно мы описываем, используется для группировки «рабочих лошадок» – блоков it. В данном случае
мы описываем функцию pow.

it(название, function() { ... })
В названии блока it человеческим языком описывается, что должна делать функция, далее следует тест, который проверяет это.

assert.equal(value1, value2)
Код внутри it, если реализация верна, должен выполняться без ошибок.

Различные функции вида assert.* используются, чтобы проверить, делает ли pow то, что задумано. Пока что нас интересует
только одна из них – assert.equal, она сравнивает свой первый аргумент со вторым и выдаёт ошибку в случае, когда они не равны.
В данном случае она проверяет, что результат pow(2, 3) равен 8.

Есть и другие виды сравнений и проверок, которые мы увидим далее.

////////////////////////////////////////before/after и beforeEach/afterEach////////////////////////////////////////////////

В каждом блоке describe можно также задать функции before/after, которые будут выполнены до/после запуска тестов,
а также beforeEach/afterEach, которые выполняются до/после каждого it.

Например:

describe("Тест", function() {

  before(function() { alert("Начало тестов"); });
  after(function() { alert("Конец тестов"); });

  beforeEach(function() { alert("Вход в тест"); });
  afterEach(function() { alert("Выход из теста"); });

  it('тест 1', function() { alert('1'); });
  it('тест 2', function() { alert('2'); });

});
Последовательность будет такой:

Начало тестов
Вход в тест
1
Выход из теста
Вход в тест
2
Выход из теста
Конец тестов

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Вот самые востребованные assert-проверки, встроенные в Chai:

assert(value) – проверяет что value является true в логическом контексте.
assert.equal(value1, value2) – проверяет равенство value1 == value2.
assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.
assert.notEqual, assert.notStrictEqual – проверки, обратные двум предыдущим.
assert.isTrue(value) – проверяет, что value === true
assert.isFalse(value) – проверяет, что value === false
…более полный список – в документации

///////////////////////

Метод str.toUpperCase()
Также у строк есть метод toUpperCase(), который возвращает строку в верхнем регистре:
////////////////////

Метод num.toFixed(n)
Есть методы и у чисел, например num.toFixed(n). Он округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки (удобно для форматированного вывода):
//////////////////////////////////////////////////////////

Значение NaN можно проверить специальной функцией isNaN(n)
//////////////////////////////////////////////////////////////////////////////////////////////////////

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity
////////////////////////////////////////////////////////////////////////////////////////////////

Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity – используйте следующую функцию isNumeric:

function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

//////////////////////////////////////

Округление
Одна из самых частых операций с числом – округление. В JavaScript существуют целых 3 функции для этого.

Math.floor
Округляет вниз
Math.ceil
Округляет вверх
Math.round
Округляет до ближайшего целого
alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3

//////////////////////////////////////////////////////////////////////////////////////////////////

Форматирование
Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString():

var number = 123456789;

alert( number.toLocaleString() ); // 123 456 789

////////////////////////////////////////////////////////////////////////////////////////

Специальные символы
Символ	Описание
\b	Backspace
\f	Form feed
\n	New line
\r	Carriage return
\t	Tab
\uNNNN	Символ в кодировке Юникод с шестнадцатеричным кодом `NNNN`. Например, `\u00A9` -- юникодное представление символа копирайт ©
Экранирование специальных символов
Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем \'

////////////////////////////////////////////////////////////////////////////////////////////////

Длина length
Одно из самых частых действий со строкой – это получение ее длины:
alert( str.length );

Доступ к символам
Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0:
alert( str.charAt(0)
Также для доступа к символу можно использовать квадратные скобки:
alert( str[0] );
Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined.

var str = "строка";
str = str[3] + str[4] + str[5];
alert( str ); // ока

Смена регистра
Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний.

На заметку:
Для красивого вызова indexOf применяется побитовый оператор НЕ '~'.
Дело в том, что вызов ~n эквивалентен выражению -(n+1), например:
alert( ~2 ); // -(2+1) = -3
alert( ~1 ); // -(1+1) = -2
alert( ~0 ); // -(0+1) = -1
alert( ~-1 ); // -(-1+1) = 0
Как видно, ~n – ноль только в случае, когда n == -1.
То есть, проверка if ( ~str.indexOf(...) ) означает, что результат indexOf отличен от -1, т.е. совпадение есть.
Вот так:
var str = "Widget";
if (~str.indexOf("get")) {
  alert( 'совпадение есть!' );
}
Вообще, использовать возможности языка неочевидным образом не рекомендуется, поскольку ухудшает читаемость кода.
Однако, в данном случае, все в порядке. Просто запомните: '~' читается как «не минус один», а "if ~str.indexOf" читается как "если найдено".

//////////////////////////////////////////////

Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.
Если аргумент end отсутствует, то идет до конца строки.

substr(start [, length])
Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов.
var str = "stringify";
str = str.substr(2,4); // ring, со 2-й позиции 4 символа
alert(str)
Если второго аргумента нет – подразумевается «до конца строки».

slice(start [, end])
Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring

Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами:
substring(start, end)
Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:
alert( "testme".substring(-2) ); // "testme", -2 становится 0
Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
alert( "testme".substring(4, -1) ); // "test"
// -1 становится 0 -> получили substring(4, 0)
// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
slice
Отрицательные значения отсчитываются от конца строки:
alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
Это гораздо более удобно, чем странная логика substring.
Отрицательное значение первого параметра поддерживается в substr во всех браузерах, кроме IE8-.
Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет slice: он и отрицательные аргументы поддерживает и работает наиболее очевидно.
String.fromCharCode(code)
Возвращает символ по коду code:
alert( String.fromCharCode(1072) ); // 'а'
…И метод для получения цифрового кода из символа:
str.charCodeAt(pos)
Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.
alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'


Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны.


/////////////////////////////////////////////////////////////////////////

Создание объектов
Пустой объект («пустой шкаф») может быть создан одним из двух синтаксисов:

1. o = new Object();
2. o = {}; // пустые фигурные скобки
Обычно все пользуются синтаксисом (2), т.к. он короче.

Удаление осуществляется командой delete
delete persone.age;

Иногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом.
Для этого есть особый оператор: "in".
if ("name" in person) {
  alert( "Свойство name существует!" );
}

Впрочем, чаще используется другой способ – сравнение значения с undefined.
Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет.
Ошибки не будет.
Но если свойство не существует, то вернется специальное значение undefined:
var person = {};
alert( person.lalala ); // undefined, нет свойства с ключом lalala

Таким образом мы можем легко проверить существование свойства – получив его и сравнив с undefined:
var person = {
name: "Василий"
};
alert( person.lalala === undefined ); // true, свойства нет
alert( person.name === undefined ); // false, свойство есть.

Записи person['name'] и person.name идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку:

Доступ к свойству через переменную
Квадратные скобки также позволяют обратиться к свойству, имя которого хранится в переменной:
var person = {};
person.age = 25;
var key = 'age';
alert( person[key] ); // выведет person['age']